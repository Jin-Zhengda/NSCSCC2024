# cache是什么？——位于CPU处理器和主存之间的桥梁，起加速存取作用

# 设计方案

## 整体策略
- 给Cache多少大小??????????????????????16KB???????????????????????
- 映射方式：二路组相联
- 替换方式：伪LRU替换法则
- DCache写策略：
  - 若在cache中——Write-Back策略：重写cache中数据并标记为脏，等到被替换的时候写入主存
  - 不在cache中——Write-Allocate策略：先从主存读取整个数据块进cache，再在cache中对目标数据重写，最后采用Write-Back策略
  - 使用WriteBuffer加速DCache写入主存的过程
- CacheAXI_Interface做总线交互仲裁?????????????????????????什么东西??????????????????????
- 动态取指结合分支预测充分爆发CPU的双发射性能。?????????????????什么东西?????????????????????????

## 地址编码
高速缓存的设计为***16KB***的二路组相联，块大小设为32个字节，即8个字(1个字=4字节)，每个字为一个bank，首先给出以下的32位**物理地址**编码规则。
- ***Tag位（物理地址高位）：20位		Index位（组地址）：8位		Offset位（块内偏移）：4位***
故共有2^8个组，即256个组(可考虑只用7位，得128个组)
offset只用高三位，共区分为8个bank
- ***Valid位（数据是否有效）：1位		Dirty位（脏标志）：1位***

每一组有两路，共用一个LRU位。
- LRU位（最近最少替换标志）：1位

### 块的数据编码如下：

| Dirty | Valid |  Tag  | Bank0 | Bank1 | Bank2 | Bank3 | Bank4 | Bank5 | Bank6 | Bank7 |
| :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: | :---: |
|   1   |   1   |  20   |  32   |  32   |  32   |  32   |  32   |  32   |  32   |  32   |

Cache size:
$2^{8}*2*2^{5}*2^{3} = 2 ^ {17} Bit = 2^{14}Byte=2^{4}KB= 16KB$

## 主存写策略
- 若数据已在Cache中，则将Cache中的数据进行修改，并标记为"脏"，等到Cache进行替换脏块时才将数据写入主存
- 否则，数据不在Cache中，则先从主存读取整块数据进Cache，进行修改，标记为脏，等待写回主存
即为Write-Back与Write-Allocate结合的策略


## Cache数据替换策略

当Cache未命中的时候，或者说需要从主存中读数据写入Cache的时候，采用的策略是伪LRU（伪近期最少使用法），对于2路组相联，对每一组（set）都设置了一位的LRU标志，为0表示way0最近没有被使用，为1同理。LRU位决定了替换该组中的块时被替换的那一个。注意，被替换的数据若是dirty的话，就必须写入内存。



## 接口设计：
### Cache模块与CPU流水线的交互接口

|name|位宽|I/O|含义|
|:---:|:---:|:---:|:---:|
|valid|1|IN|表明请求有效（使能）|
|op|1|IN|1表示写，0表示读|
|index|8|IN|地址的index域(addr[11:4])|
|tag|20|IN|经过虚实转换后的paddr形成的tag，逻辑电路故与index同拍|
|offset|4|IN|地址的offset域(addr[3:0])|
|wstrb|4|IN|写字节使能信号|
|wdata|32|IN|写数据|
|addr_ok|1|OUT|该次请求的地址传输ok|
|data_ok|1|OUT|该次请求的数据传输ok|
|rdata|32|OUT|读cache的结果|